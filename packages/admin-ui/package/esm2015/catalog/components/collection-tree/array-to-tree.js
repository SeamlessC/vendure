/**
 * Builds a tree from an array of nodes which have a parent.
 * Based on https://stackoverflow.com/a/31247960/772859, modified to preserve ordering.
 */
export function arrayToTree(nodes, currentState, expandedIds = []) {
    var _a, _b;
    const topLevelNodes = [];
    const mappedArr = {};
    const currentStateMap = treeToMap(currentState);
    // First map the nodes of the array to an object -> create a hash table.
    for (const node of nodes) {
        mappedArr[node.id] = Object.assign(Object.assign({}, node), { children: [] });
    }
    for (const id of nodes.map(n => n.id)) {
        if (mappedArr.hasOwnProperty(id)) {
            const mappedElem = mappedArr[id];
            mappedElem.expanded = (_b = (_a = currentStateMap.get(id)) === null || _a === void 0 ? void 0 : _a.expanded) !== null && _b !== void 0 ? _b : expandedIds.includes(id);
            const parent = mappedElem.parent;
            if (!parent) {
                continue;
            }
            // If the element is not at the root level, add it to its parent array of children.
            const parentIsRoot = !mappedArr[parent.id];
            if (!parentIsRoot) {
                if (mappedArr[parent.id]) {
                    mappedArr[parent.id].children.push(mappedElem);
                }
                else {
                    mappedArr[parent.id] = { children: [mappedElem] };
                }
            }
            else {
                topLevelNodes.push(mappedElem);
            }
        }
    }
    // tslint:disable-next-line:no-non-null-assertion
    const rootId = topLevelNodes.length ? topLevelNodes[0].parent.id : undefined;
    return { id: rootId, children: topLevelNodes };
}
/**
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 */
function treeToMap(tree) {
    const nodeMap = new Map();
    function visit(node) {
        nodeMap.set(node.id, node);
        node.children.forEach(visit);
    }
    if (tree) {
        visit(tree);
    }
    return nodeMap;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdG8tdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRyZWUvYXJyYXktdG8tdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUN2QixLQUFVLEVBQ1YsWUFBMEIsRUFDMUIsY0FBd0IsRUFBRTs7SUFFMUIsTUFBTSxhQUFhLEdBQXVCLEVBQUUsQ0FBQztJQUM3QyxNQUFNLFNBQVMsR0FBa0MsRUFBRSxDQUFDO0lBQ3BELE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUVoRCx3RUFBd0U7SUFDeEUsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7UUFDdEIsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsbUNBQVMsSUFBWSxLQUFFLFFBQVEsRUFBRSxFQUFFLEdBQUUsQ0FBQztLQUMzRDtJQUVELEtBQUssTUFBTSxFQUFFLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUNuQyxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDOUIsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsTUFBQSxNQUFBLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLDBDQUFFLFFBQVEsbUNBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNwRixNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO1lBQ2pDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ1QsU0FBUzthQUNaO1lBQ0QsbUZBQW1GO1lBQ25GLE1BQU0sWUFBWSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNmLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRTtvQkFDdEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUNsRDtxQkFBTTtvQkFDSCxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQVMsQ0FBQztpQkFDNUQ7YUFDSjtpQkFBTTtnQkFDSCxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ2xDO1NBQ0o7S0FDSjtJQUNELGlEQUFpRDtJQUNqRCxNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzlFLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsQ0FBQztBQUNuRCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsU0FBUyxDQUFzQixJQUFrQjtJQUN0RCxNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBdUIsQ0FBQztJQUMvQyxTQUFTLEtBQUssQ0FBQyxJQUFpQjtRQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUNELElBQUksSUFBSSxFQUFFO1FBQ04sS0FBSyxDQUFDLElBQW1CLENBQUMsQ0FBQztLQUM5QjtJQUNELE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBIYXNQYXJlbnQgPSB7IGlkOiBzdHJpbmc7IHBhcmVudD86IHsgaWQ6IHN0cmluZyB9IHwgbnVsbCB9O1xuZXhwb3J0IHR5cGUgVHJlZU5vZGU8VCBleHRlbmRzIEhhc1BhcmVudD4gPSBUICYgeyBjaGlsZHJlbjogQXJyYXk8VHJlZU5vZGU8VD4+OyBleHBhbmRlZDogYm9vbGVhbiB9O1xuZXhwb3J0IHR5cGUgUm9vdE5vZGU8VCBleHRlbmRzIEhhc1BhcmVudD4gPSB7IGlkPzogc3RyaW5nOyBjaGlsZHJlbjogQXJyYXk8VHJlZU5vZGU8VD4+IH07XG5cbi8qKlxuICogQnVpbGRzIGEgdHJlZSBmcm9tIGFuIGFycmF5IG9mIG5vZGVzIHdoaWNoIGhhdmUgYSBwYXJlbnQuXG4gKiBCYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzEyNDc5NjAvNzcyODU5LCBtb2RpZmllZCB0byBwcmVzZXJ2ZSBvcmRlcmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9UcmVlPFQgZXh0ZW5kcyBIYXNQYXJlbnQ+KFxuICAgIG5vZGVzOiBUW10sXG4gICAgY3VycmVudFN0YXRlPzogUm9vdE5vZGU8VD4sXG4gICAgZXhwYW5kZWRJZHM6IHN0cmluZ1tdID0gW10sXG4pOiBSb290Tm9kZTxUPiB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlczogQXJyYXk8VHJlZU5vZGU8VD4+ID0gW107XG4gICAgY29uc3QgbWFwcGVkQXJyOiB7IFtpZDogc3RyaW5nXTogVHJlZU5vZGU8VD4gfSA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZU1hcCA9IHRyZWVUb01hcChjdXJyZW50U3RhdGUpO1xuXG4gICAgLy8gRmlyc3QgbWFwIHRoZSBub2RlcyBvZiB0aGUgYXJyYXkgdG8gYW4gb2JqZWN0IC0+IGNyZWF0ZSBhIGhhc2ggdGFibGUuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG1hcHBlZEFycltub2RlLmlkXSA9IHsgLi4uKG5vZGUgYXMgYW55KSwgY2hpbGRyZW46IFtdIH07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpZCBvZiBub2Rlcy5tYXAobiA9PiBuLmlkKSkge1xuICAgICAgICBpZiAobWFwcGVkQXJyLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVkRWxlbSA9IG1hcHBlZEFycltpZF07XG4gICAgICAgICAgICBtYXBwZWRFbGVtLmV4cGFuZGVkID0gY3VycmVudFN0YXRlTWFwLmdldChpZCk/LmV4cGFuZGVkID8/IGV4cGFuZGVkSWRzLmluY2x1ZGVzKGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG1hcHBlZEVsZW0ucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBhdCB0aGUgcm9vdCBsZXZlbCwgYWRkIGl0IHRvIGl0cyBwYXJlbnQgYXJyYXkgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJc1Jvb3QgPSAhbWFwcGVkQXJyW3BhcmVudC5pZF07XG4gICAgICAgICAgICBpZiAoIXBhcmVudElzUm9vdCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRBcnJbcGFyZW50LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXBwZWRBcnJbcGFyZW50LmlkXS5jaGlsZHJlbi5wdXNoKG1hcHBlZEVsZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEFycltwYXJlbnQuaWRdID0geyBjaGlsZHJlbjogW21hcHBlZEVsZW1dIH0gYXMgYW55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxOb2Rlcy5wdXNoKG1hcHBlZEVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCByb290SWQgPSB0b3BMZXZlbE5vZGVzLmxlbmd0aCA/IHRvcExldmVsTm9kZXNbMF0ucGFyZW50IS5pZCA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyBpZDogcm9vdElkLCBjaGlsZHJlbjogdG9wTGV2ZWxOb2RlcyB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGV4aXN0aW5nIHRyZWUgKGFzIGdlbmVyYXRlZCBieSB0aGUgYXJyYXlUb1RyZWUgZnVuY3Rpb24pIGludG8gYSBmbGF0XG4gKiBNYXAuIFRoaXMgaXMgdXNlZCB0byBwZXJzaXN0IGNlcnRhaW4gc3RhdGVzIChlLmcuIGBleHBhbmRlZGApIHdoZW4gcmUtYnVpbGRpbmcgdGhlXG4gKiB0cmVlLlxuICovXG5mdW5jdGlvbiB0cmVlVG9NYXA8VCBleHRlbmRzIEhhc1BhcmVudD4odHJlZT86IFJvb3ROb2RlPFQ+KTogTWFwPHN0cmluZywgVHJlZU5vZGU8VD4+IHtcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFRyZWVOb2RlPFQ+PigpO1xuICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGU6IFRyZWVOb2RlPFQ+KSB7XG4gICAgICAgIG5vZGVNYXAuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2godmlzaXQpO1xuICAgIH1cbiAgICBpZiAodHJlZSkge1xuICAgICAgICB2aXNpdCh0cmVlIGFzIFRyZWVOb2RlPFQ+KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVNYXA7XG59XG4iXX0=